#!/usr/bin/env node

const { execSync } = require('child_process');
const https = require('https');

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

function getRepoInfo() {
  try {
    const remoteUrl = execSync('git remote get-url origin', { encoding: 'utf-8' }).trim();
    const match = remoteUrl.match(/github\.com[/:]([^/]+\/[^/]+?)(?:\.git)?$/);
    if (match) {
      return match[1];
    }
    throw new Error('Could not parse GitHub repository from remote URL');
  } catch (error) {
    throw new Error('Not a git repository or no GitHub remote found');
  }
}

function githubRequest(path, method = 'GET', body = null) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'api.github.com',
      path: path,
      method: method,
      headers: {
        'User-Agent': 'github-task-handler',
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': `token ${GITHUB_TOKEN}`
      }
    };

    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        if (res.statusCode >= 200 && res.statusCode < 300) {
          resolve(data ? JSON.parse(data) : {});
        } else {
          reject(new Error(`GitHub API error: ${res.statusCode} ${data}`));
        }
      });
    });

    req.on('error', reject);
    if (body) {
      req.write(JSON.stringify(body));
    }
    req.end();
  });
}

async function checkUserPermission(owner, repo, username) {
  try {
    const result = await githubRequest(`/repos/${owner}/${repo}/collaborators/${username}/permission`);
    const permission = result.permission;
    return permission === 'admin' || permission === 'maintain' || permission === 'write';
  } catch (error) {
    console.error(`Warning: Could not check permission for user ${username}: ${error.message}`);
    return false;
  }
}

async function getRepoCollaborators(owner, repo) {
  try {
    const collaborators = await githubRequest(`/repos/${owner}/${repo}/collaborators?affiliation=direct`);
    const adminUsers = new Set();
    for (const collab of collaborators) {
      if (collab.permissions && (collab.permissions.admin || collab.permissions.maintain)) {
        adminUsers.add(collab.login);
      }
    }
    return adminUsers;
  } catch (error) {
    console.error(`Warning: Could not fetch collaborators: ${error.message}`);
    return new Set();
  }
}

function isTaskIssue(title) {
  return title.toLowerCase().startsWith('[task]');
}

function execGit(command, silent = false) {
  try {
    const result = execSync(command, { encoding: 'utf-8' }).trim();
    return result;
  } catch (error) {
    if (!silent) {
      console.error(`Git command failed: ${command}`);
      console.error(error.message);
    }
    throw error;
  }
}

function getCurrentBranch() {
  return execGit('git branch --show-current');
}

function hasUncommittedChanges() {
  const status = execGit('git status --porcelain');
  return status.length > 0;
}

function createBranch(issueNumber, issueTitle) {
  const sanitizedTitle = issueTitle
    .toLowerCase()
    .replace(/^\[task\]\s*/i, '')
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .substring(0, 50);
  const branchName = `task/issue-${issueNumber}-${sanitizedTitle}`;
  
  console.log(`Creating branch: ${branchName}`);
  execGit(`git checkout -b ${branchName}`);
  
  return branchName;
}

function commitChanges(message) {
  console.log('Staging all changes...');
  execGit('git add -A');
  
  console.log(`Committing with message: ${message}`);
  execGit(`git commit -m "${message}"`);
}

function pushBranch(branchName, owner, repo) {
  console.log(`Pushing branch ${branchName} to origin...`);
  const tokenUrl = `https://${GITHUB_TOKEN}@github.com/${owner}/${repo}.git`;
  execGit(`git push -u origin ${branchName}`);
}

async function createPullRequest(owner, repo, branchName, issueNumber, issueTitle, issueBody) {
  const prTitle = `Resolve #${issueNumber}: ${issueTitle}`;
  const prBody = `## Summary\n\nThis PR resolves issue #${issueNumber}\n\n## Original Issue\n\n${issueBody || 'No description provided.'}\n\n## Changes\n\n- Implemented the requested feature/fix\n\nCloses #${issueNumber}`;

  console.log(`Creating pull request for issue #${issueNumber}...`);
  
  const result = await githubRequest(`/repos/${owner}/${repo}/pulls`, 'POST', {
    title: prTitle,
    head: branchName,
    base: 'main',
    body: prBody
  });

  console.log(`Pull request created: ${result.html_url}`);
  return result;
}

async function createIssueComment(owner, repo, issueNumber, prUrl, prTitle) {
  const commentBody = `## ðŸ”— Pull Request Created\n\nA pull request has been created for this task:\n\n**PR:** [${prTitle}](${prUrl})\n\n---\n*This comment was automatically generated by github-task-handler*`;

  console.log(`Adding comment to issue #${issueNumber}...`);
  
  await githubRequest(`/repos/${owner}/${repo}/issues/${issueNumber}/comments`, 'POST', {
    body: commentBody
  });

  console.log(`Comment added to issue #${issueNumber}`);
}

function showHelp() {
  console.log(`
GitHub Task Handler - Manage GitHub issues as development tasks

Usage:
  node index.js <command> [options]

Commands:
  fetch              Fetch and list task issues from GitHub
                     Options: --json (output as JSON only)

  start              Start working on an issue
                     Args: <issue-number>
                     Creates a new branch for development

  submit             Submit completed work for an issue
                     Args: <issue-number>
                     Options: --message "commit message"
                     Commits changes, pushes branch, creates PR, and comments on issue

  help               Show this help message

Environment Variables:
  GITHUB_TOKEN       GitHub Personal Access Token (required)
  GITHUB_REPOSITORY  Repository in format owner/repo (optional, auto-detected)

Examples:
  node index.js fetch
  node index.js start 1
  node index.js submit 1 --message "Implement feature X"
`);
}

async function fetchTasks(options = {}) {
  const repoPath = process.env.GITHUB_REPOSITORY || getRepoInfo();
  const [owner, repo] = repoPath.split('/');

  if (!options.json) {
    console.log(`Fetching issues from ${owner}/${repo}...`);
  }

  let adminUsers;
  try {
    adminUsers = await getRepoCollaborators(owner, repo);
    if (!options.json) {
      console.log(`Found ${adminUsers.size} admin/maintainer users`);
    }
  } catch (error) {
    console.error(`Error fetching collaborators: ${error.message}`);
    process.exit(1);
  }

  let issues;
  try {
    issues = await githubRequest(`/repos/${owner}/${repo}/issues?state=open&per_page=100`);
  } catch (error) {
    console.error(`Error fetching issues: ${error.message}`);
    process.exit(1);
  }

  const taskIssues = [];

  for (const issue of issues) {
    if (!isTaskIssue(issue.title)) {
      continue;
    }

    const author = issue.user.login;
    const isAdmin = adminUsers.has(author) || await checkUserPermission(owner, repo, author);

    if (isAdmin) {
      taskIssues.push({
        number: issue.number,
        title: issue.title,
        author: author,
        body: issue.body || '',
        url: issue.html_url
      });
    }
  }

  if (options.json) {
    console.log(JSON.stringify(taskIssues, null, 2));
    return taskIssues;
  }

  if (taskIssues.length === 0) {
    console.log('\nNo task issues found from admin users.');
    return [];
  }

  console.log(`\nFound ${taskIssues.length} task issue(s):\n`);

  for (const task of taskIssues) {
    console.log('='.repeat(60));
    console.log(`Issue #${task.number}: ${task.title}`);
    console.log(`Author: ${task.author}`);
    console.log(`URL: ${task.url}`);
    console.log('-'.repeat(60));
    console.log('Task Description:');
    console.log(task.body);
    console.log('='.repeat(60));
    console.log('\n');
  }

  console.log('TASKS_OUTPUT_START');
  console.log(JSON.stringify(taskIssues, null, 2));
  console.log('TASKS_OUTPUT_END');

  return taskIssues;
}

async function startTask(issueNumber) {
  const repoPath = process.env.GITHUB_REPOSITORY || getRepoInfo();
  const [owner, repo] = repoPath.split('/');

  console.log(`Starting work on issue #${issueNumber}...`);

  let issue;
  try {
    issue = await githubRequest(`/repos/${owner}/${repo}/issues/${issueNumber}`);
  } catch (error) {
    console.error(`Error fetching issue #${issueNumber}: ${error.message}`);
    process.exit(1);
  }

  if (issue.state !== 'open') {
    console.error(`Issue #${issueNumber} is not open (state: ${issue.state})`);
    process.exit(1);
  }

  const currentBranch = getCurrentBranch();
  if (currentBranch !== 'main' && currentBranch !== 'master') {
    console.log(`Warning: Currently on branch ${currentBranch}`);
    console.log('Switching to main branch first...');
    execGit('git checkout main 2>/dev/null || git checkout master');
  }

  execGit('git pull origin main 2>/dev/null || git pull origin master');

  const branchName = createBranch(issueNumber, issue.title);

  console.log(`\nâœ… Ready to work on issue #${issueNumber}`);
  console.log(`Branch: ${branchName}`);
  console.log(`\nTask: ${issue.title}`);
  console.log(`\nDescription:\n${issue.body || 'No description'}`);

  return {
    branchName,
    issue: {
      number: issueNumber,
      title: issue.title,
      body: issue.body
    }
  };
}

async function submitTask(issueNumber, commitMessage) {
  const repoPath = process.env.GITHUB_REPOSITORY || getRepoInfo();
  const [owner, repo] = repoPath.split('/');

  console.log(`Submitting work for issue #${issueNumber}...`);

  let issue;
  try {
    issue = await githubRequest(`/repos/${owner}/${repo}/issues/${issueNumber}`);
  } catch (error) {
    console.error(`Error fetching issue #${issueNumber}: ${error.message}`);
    process.exit(1);
  }

  const currentBranch = getCurrentBranch();
  console.log(`Current branch: ${currentBranch}`);

  if (hasUncommittedChanges()) {
    const message = commitMessage || `Complete task for issue #${issueNumber}: ${issue.title}`;
    commitChanges(message);
  } else {
    console.log('No uncommitted changes found.');
  }

  pushBranch(currentBranch, owner, repo);

  const pr = await createPullRequest(owner, repo, currentBranch, issueNumber, issue.title, issue.body);

  await createIssueComment(owner, repo, issueNumber, pr.html_url, pr.title);

  console.log('\nâœ… Task submitted successfully!');
  console.log(`   Branch: ${currentBranch}`);
  console.log(`   Pull Request: ${pr.html_url}`);
  console.log(`   Issue: ${issue.html_url}`);

  return {
    branchName: currentBranch,
    pullRequest: pr,
    issue: issue
  };
}

function parseArgs() {
  const args = process.argv.slice(2);
  const command = args[0];

  if (!command || command === 'help') {
    showHelp();
    return;
  }

  const options = {};
  let issueNumber = null;

  for (let i = 1; i < args.length; i++) {
    if (args[i].startsWith('--')) {
      const key = args[i].slice(2);
      const value = args[i + 1] && !args[i + 1].startsWith('--') ? args[i + 1] : true;
      options[key] = value;
      if (typeof value === 'string') i++;
    } else if (!isNaN(parseInt(args[i]))) {
      issueNumber = parseInt(args[i]);
    }
  }

  switch (command) {
    case 'fetch':
      fetchTasks(options);
      break;
    case 'start':
      if (!issueNumber) {
        console.error('Error: Issue number is required for start command');
        process.exit(1);
      }
      startTask(issueNumber);
      break;
    case 'submit':
      if (!issueNumber) {
        console.error('Error: Issue number is required for submit command');
        process.exit(1);
      }
      submitTask(issueNumber, options.message);
      break;
    default:
      console.error(`Unknown command: ${command}`);
      showHelp();
      process.exit(1);
  }
}

async function main() {
  if (!GITHUB_TOKEN) {
    console.error('Error: GITHUB_TOKEN environment variable is required');
    console.error('Please set it with: export GITHUB_TOKEN=your_token_here');
    process.exit(1);
  }

  parseArgs();
}

main().catch(error => {
  console.error('Fatal error:', error.message);
  process.exit(1);
});
